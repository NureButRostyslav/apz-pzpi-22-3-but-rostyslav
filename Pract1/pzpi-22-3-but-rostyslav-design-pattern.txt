Харківський університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії





ЗВІТ
з практичного заняття №1  
з дисципліни  «Архітектура програмного забезпечення»
на тему: «Патерни проєктування»





Виконав ст. гр ПЗПІ-22-3
Бут Ростислав Сергійович


Перевірив
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович







Харків 2025


1 ІСТОРІЯ ЗМІН


№      Дата        Версія звіту      Опис змін та виправлень
1   18.03.2025        0.1            Створено загальну структуру звіту. Написано пункт 2.
2   19.03.2025        0.1            Написані пункти 3 та 4.
3   20.03.2025        0.1            Додано слайди презентації в додатку Б. Додано приклади програмного коду в додатку В.
4   12.04.2025        0.1            Створено та завантажено відеопояснення на платформу YouTube в додатку А.


2 ЗАВДАННЯ


    Необхідно дослідити патерн проєктування Adapter та його застосування для інтеграції несумісних інтерфейсів. Потрібно реалізувати приклади об’єктного та класового адаптера, порівняти їх з іншими методами перетворення даних та оцінити ефективність у різних сценаріях. На основі аналізу слід визначити переваги, недоліки та доцільність використання цього патерна.


3 ОПИС ВИКОНАНОЇ РОБОТИ


     У ході виконання роботи було досліджено патерн проєктування Adapter та його роль у вирішенні проблеми несумісності інтерфейсів у програмуванні. Adapter є структурним патерном, який дозволяє об’єднати класи з несумісними інтерфейсами, надаючи проміжний рівень для їх взаємодії. Основна ідея полягає в тому, щоб створити проміжний клас (адаптер), який перетворює один інтерфейс на інший, забезпечуючи коректну роботу старого та нового коду без змін у початкових класах. Це особливо корисно при інтеграції застарілих бібліотек, API або сторонніх сервісів у сучасні додатки.
Проведено теоретичний аналіз, у якому розглянуто визначення патерна, його основні принципи, випадки використання та ключові переваги. Було вивчено два основні підходи до реалізації адаптера:
  Об’єктний адаптер – використовує композицію, тобто адаптер містить об’єкт іншого класу та викликає його методи, перетворюючи їх у потрібний формат.
Класовий адаптер – використовує спадкування та перевизначає методи батьківського класу, змінюючи їхню поведінку відповідно до потреб клієнтського коду.
Розглянуто відмінності між підходами, їх переваги та недоліки. Зокрема, об’єктний адаптер є гнучкішим, оскільки дозволяє адаптувати кілька класів одночасно, тоді як класовий адаптер простіший у реалізації, але вимагає успадкування, що обмежує його використання в мовах програмування без підтримки множинного спадкування. Основні теоретичні положення та пояснення представлено у презентації, відеозапис якої доступний за посиланням у додатку А.
Розроблено практичні приклади, що демонструють використання патерна Adapter у двох реальних сценаріях.
     Перший сценарій стосувався адаптації API, де існує проблема несумісності форматів даних між старою та новою версією сервісу. У початковій реалізації код працював без адаптера, що вимагало ручного перетворення даних під час кожного виклику API. Це ускладнювало підтримку та масштабування додатка. Було розроблено рішення з об’єктним адаптером, який автоматично перетворює отримані дані у потрібний формат, приховуючи деталі реалізації від користувача. Відповідні слайди презентації, що пояснюють цей приклад, наведено у додатку Б, а вихідний код розміщено у додатку В.
    Другий сценарій стосувався конвертації даних між XML та JSON, коли стара система використовує XML, а нова працює виключно з JSON. У коді без адаптера доводилося вручну розбирати XML, що робило процес складним та неуніверсальним. Було створено класовий адаптер, який автоматично перетворює XML у JSON, спрощуючи інтеграцію старого сервісу з новими додатками. Цей підхід значно зменшив обсяг коду, що потребував змін, та зробив перетворення даних прозорим для кінцевих користувачів. Завдяки використанню адаптера вдалося значно спростити взаємодію між сервісами та зробити процес перетворення форматів більш ефективним.
    Після реалізації було проведено аналіз отриманих рішень, розглянуто переваги використання адаптера у порівнянні з альтернативними методами, такими як створення додаткових функцій або безпосередня зміна вихідного коду. Також були сформульовані висновки щодо ситуацій, у яких доцільно використовувати патерн Adapter, а також його можливі обмеження. У цілому, дана робота продемонструвала, що Adapter є ефективним інструментом для інтеграції різних систем, покращення підтримки коду та підвищення гнучкості програмних рішень.


4 ВИСНОВКИ


Виконана робота підтвердила, що патерн Adapter є важливим інструментом у розробці програмного забезпечення, який допомагає спрощувати інтеграцію, покращувати архітектуру та робити код більш підтримуваним і масштабованим.


ДОДАТОК А
Посилання на відеозапис доповіді


Відеозапис доповіді на YouTube: https://youtu.be/OwhpJeo6RfY

Хронологічний опис доповіді:
00:00-00:10 – Вітання. Оголошується ім’я доповідача, його академічна група та тема доповіді.
00:10-00:32 – Зміст. Короткий огляд основних тем, що будуть розглянуті у презентації.
00:32-01:05 – Вступ. Актуальність патерна Adapter у сучасній розробці. Пояснення важливості патерну.
01:05-01:44 – Визначення патерна та його ключова роль у програмуванні.
01:44-02:19 – Проблематика розробки. Чому виникає проблема несумісності інтерфейсів? Реальні приклади з практики.
02:19-03:20 – Рішення: Використання Adapter як об'єкта-перекладача. Як адаптер допомагає об'єднати несумісні системи?
03:20-04:17 – Принцип роботи Adapter: Об’єктний та класовий підходи. Пояснення двох підходів реалізації: об’єктного та класового адаптерів.
04:17-06:27 – Приклад 1: Код з використанням об’єктного підходу. Демонстрація проблеми несумісності API без адаптера.
06:27-08:12 – Приклад 2: Код з використанням класового підходу. Проблема перетворення XML у JSON без адаптера.
08:12-10:05 – Переваги та недоліки. Аналіз сильних і слабких сторін різних підходів патерну Adapter у розробці програмного забезпечення.
10:05-10:36 – Висновки. Підсумок основних ідей доповіді.
10:36-10:45 – Список використаних джерел. Посилання на книги та документацію, використані у доповіді.


ДОДАТОК Б
Слайди презентації

Рисунок Б.1 – Титульний лист
  
Рисунок Б.2 – Зміст доповіді

Рисунок Б.3 – Вступ. Проблема несумісності інтерфейсів
 
Рисунок Б.4 – Загальне визначення патерна

Рисунок Б.5 – Проблематика розробки

Рисунок Б.6 – Використання Adapter як об'єкта-перекладача
 
Рисунок Б.7 – Принцип роботи Adapter: Об’єктний та класовий підходи

Рисунок Б.8 – Приклад використання об’єктного підходу

Рисунок Б.9  – Приклад використання класового підходу

Рисунок Б.10 – Переваги та недоліки об’єктного та класового підходів
 
Рисунок Б.11 – Підсумок основних ідей та висновки
  
Рисунок Б.12 – Список використаних джерел


ДОДАТОК В
Приклади програмного коду


Приклад 1: API-запити (Об’єктний адаптер):
1.1 Без адаптера (ручна адаптація формату):
1. # Старий API (Adaptee)
2. class LegacyAPI:
3.     def get_data(self):
4.         # Повертає дані у старому форматі
5.         return {"name": "John", "surname": "Doe", "age": 30}
6. 
7. # Клієнтський код (новий формат очікує об'єднане ім'я)
8. def process_data():
9.     legacy = LegacyAPI()
10.     data = legacy.get_data()
11. 
12.     # Ручна адаптація
13.     full_name = f"{data['name']} {data['surname']}"
14.     new_data = {
15.         "fullName": full_name,
16.         "age": data["age"]
17.     }
18. 
19.     print("Processed data:", new_data)
20. 
21. process_data()

1.2 З адаптером (об’єктний адаптер):
1. # Старий API (Adaptee)
2. class LegacyAPI:
3.     def get_data(self):
4.         return {"name": "John", "surname": "Doe", "age": 30}
5. 
6. # Новий інтерфейс (Target)
7. class NewAPIInterface:
8.     def get_formatted_data(self):
9.         pass
10. 
11. # Адаптер (Object Adapter)
12. class LegacyAPIAdapter(NewAPIInterface):
13.     def __init__(self, legacy_api):
14.         self.legacy_api = legacy_api
15. 
16.     def get_formatted_data(self):
17.         old_data = self.legacy_api.get_data()
18.         return {
19.             "fullName": f"{old_data['name']} {old_data['surname']}",
20.             "age": old_data["age"]
21.         }
22. 
23. # Клієнтський код
24. def process_data():
25.     adapter = LegacyAPIAdapter(LegacyAPI())
26.     new_data = adapter.get_formatted_data()
27.     print("Processed data:", new_data)
28. 
29. process_data()

Приклад 2: Конвертація XML → JSON (Класовий адаптер):
2.1 Без адаптера (ручне перетворення XML → JSON):
1. import xml.etree.ElementTree as ET
2. import json
3. 
4. # Стара система повертає XML
5. class XMLService:
6.     def get_xml(self):
7.         return "<person><name>John</name><age>30</age></person>"
8. 
9. # Клієнтський код
10. def process_data():
11.     xml_service = XMLService()
12.     xml_data = xml_service.get_xml()
13. 
14.     # Ручне перетворення
15.     root = ET.fromstring(xml_data)
16.     json_data = {
17.         "name": root.find("name").text,
18.         "age": int(root.find("age").text)
19.     }
20. 
21.     print("Processed JSON:", json.dumps(json_data, indent=2))
22. 
23. process_data()

2.2 З адаптером (класовий адаптер):
1. import xml.etree.ElementTree as ET
2. import json
3. 
4. # Стара система (Adaptee)
5. class XMLService:
6.     def get_xml(self):
7.         return "<person><name>John</name><age>30</age></person>"
8. 
9. # Новий інтерфейс (Target)
10. class JSONServiceInterface:
11.     def get_json(self):
12.         pass
13. 
14. # Класовий адаптер
15. class XMLtoJSONAdapter(XMLService, JSONServiceInterface):
16.     def get_json(self):
17.         xml_data = self.get_xml()
18.         root = ET.fromstring(xml_data)
19.         return {
20.             "name": root.find("name").text,
21.             "age": int(root.find("age").text)
22.         }
23. 
24. # Клієнтський код
25. def process_data():
26.     adapter = XMLtoJSONAdapter()
27.     json_data = adapter.get_json()
28.     print("Processed JSON:", json.dumps(json_data, indent=2))
29. 
30. process_data()
