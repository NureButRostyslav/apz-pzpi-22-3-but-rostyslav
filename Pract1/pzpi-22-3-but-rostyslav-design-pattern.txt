Харківський університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії





ЗВІТ
з практичного заняття №1  
з дисципліни  «Архітектура програмного забезпечення»
на тему: «Патерни проєктування»





Виконав ст. гр ПЗПІ-22-3
Бут Ростислав Сергійович


Перевірив
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович







Харків 2025


1 ІСТОРІЯ ЗМІН


№      Дата        Версія звіту      Опис змін та виправлень
1   18.03.2025        0.1            Створено загальну структуру звіту. Написано пункт 2.
2   19.03.2025        0.1            Написані пункти 3 та 4.
3   20.03.2025        0.1            Додано слайди презентації в додатку Б. Додано приклади програмного коду в додатку В.
4   21.03.2025        0.1            Створено та завантажено відеопояснення на платформу YouTube в додатку А.


2 ЗАВДАННЯ


    Необхідно дослідити патерн проєктування Adapter та його застосування для інтеграції несумісних інтерфейсів. Потрібно реалізувати приклади об’єктного та класового адаптера, порівняти їх з іншими методами перетворення даних та оцінити ефективність у різних сценаріях. На основі аналізу слід визначити переваги, недоліки та доцільність використання цього патерна.


3 ОПИС ВИКОНАНОЇ РОБОТИ


     У ході виконання роботи було досліджено патерн проєктування Adapter та його роль у вирішенні проблеми несумісності інтерфейсів у програмуванні. Adapter є структурним патерном, який дозволяє об’єднати класи з несумісними інтерфейсами, надаючи проміжний рівень для їх взаємодії. Основна ідея полягає в тому, щоб створити проміжний клас (адаптер), який перетворює один інтерфейс на інший, забезпечуючи коректну роботу старого та нового коду без змін у початкових класах. Це особливо корисно при інтеграції застарілих бібліотек, API або сторонніх сервісів у сучасні додатки.
Проведено теоретичний аналіз, у якому розглянуто визначення патерна, його основні принципи, випадки використання та ключові переваги. Було вивчено два основні підходи до реалізації адаптера:
  Об’єктний адаптер – використовує композицію, тобто адаптер містить об’єкт іншого класу та викликає його методи, перетворюючи їх у потрібний формат.
Класовий адаптер – використовує спадкування та перевизначає методи батьківського класу, змінюючи їхню поведінку відповідно до потреб клієнтського коду.
Розглянуто відмінності між підходами, їх переваги та недоліки. Зокрема, об’єктний адаптер є гнучкішим, оскільки дозволяє адаптувати кілька класів одночасно, тоді як класовий адаптер простіший у реалізації, але вимагає успадкування, що обмежує його використання в мовах програмування без підтримки множинного спадкування. Основні теоретичні положення та пояснення представлено у презентації, відеозапис якої доступний за посиланням у додатку А.
Розроблено практичні приклади, що демонструють використання патерна Adapter у двох реальних сценаріях.
     Перший сценарій стосувався адаптації API, де існує проблема несумісності форматів даних між старою та новою версією сервісу. У початковій реалізації код працював без адаптера, що вимагало ручного перетворення даних під час кожного виклику API. Це ускладнювало підтримку та масштабування додатка. Було розроблено рішення з об’єктним адаптером, який автоматично перетворює отримані дані у потрібний формат, приховуючи деталі реалізації від користувача. Відповідні слайди презентації, що пояснюють цей приклад, наведено у додатку Б, а вихідний код розміщено у додатку В.
    Другий сценарій стосувався конвертації даних між XML та JSON, коли стара система використовує XML, а нова працює виключно з JSON. У коді без адаптера доводилося вручну розбирати XML, що робило процес складним та неуніверсальним. Було створено класовий адаптер, який автоматично перетворює XML у JSON, спрощуючи інтеграцію старого сервісу з новими додатками. Цей підхід значно зменшив обсяг коду, що потребував змін, та зробив перетворення даних прозорим для кінцевих користувачів. Завдяки використанню адаптера вдалося значно спростити взаємодію між сервісами та зробити процес перетворення форматів більш ефективним.
    Після реалізації було проведено аналіз отриманих рішень, розглянуто переваги використання адаптера у порівнянні з альтернативними методами, такими як створення додаткових функцій або безпосередня зміна вихідного коду. Також були сформульовані висновки щодо ситуацій, у яких доцільно використовувати патерн Adapter, а також його можливі обмеження. У цілому, дана робота продемонструвала, що Adapter є ефективним інструментом для інтеграції різних систем, покращення підтримки коду та підвищення гнучкості програмних рішень.


4 ВИСНОВКИ


Виконана робота підтвердила, що патерн Adapter є важливим інструментом у розробці програмного забезпечення, який допомагає спрощувати інтеграцію, покращувати архітектуру та робити код більш підтримуваним і масштабованим.


ДОДАТОК А
Посилання на відеозапис доповіді


Відеозапис доповіді на YouTube: https://

Хронологічний опис доповіді:

00:00-00:15 – Вітання. Оголошується ім’я доповідача, його академічна група та тема доповіді.
00:15-00:35 – Зміст. Короткий огляд основних тем, що будуть розглянуті у презентації.
00:35-01:05 – Вступ. Актуальність патерна Adapter у сучасній розробці. Чому важливо розуміти цей патерн?
01:05-01:40 – Що таке патерн Adapter? Визначення патерна та його ключова роль у програмуванні.
01:40-02:15 – Проблематика розробки. Чому виникає проблема несумісності інтерфейсів.
02:15-02:50 – Рішення: Використання Adapter як об'єкта-перекладача. Як адаптер допомагає об'єднати несумісні системи?
02:50-03:30 – Принцип роботи Adapter: Об’єктний та класовий підходи. Пояснення двох підходів реалізації: об’єктного та класового адаптерів.
03:30-04:10 – Приклад 1: Код без адаптера (Об’єктний Adapter). Демонстрація проблеми несумісності API без адаптера.
04:10-04:50 – Приклад 2: Код із адаптером (Об’єктний Adapter). Реалізація рішення з використанням об’єктного адаптера.
04:50-05:30 – Приклад 3: Код без адаптера (Класовий Adapter). Проблема перетворення XML у JSON без адаптера.
05:30-06:10 – Приклад 4: Код із адаптером (Класовий Adapter). Використання класового адаптера для автоматизації перетворення форматів.
06:10-06:50 – Переваги використання адаптера. Різниця адаптера від функції. Чому адаптер є більш гнучким рішенням, ніж прості функції або рефакторинг коду?
06:50-07:30 – Переваги та недоліки. Аналіз сильних і слабких сторін патерна Adapter у розробці програмного забезпечення.
07:30-08:10 – Коли потрібно та коли не потрібно використовувати патерн. Рекомендації щодо застосування в реальних проєктах.
08:10-08:40 – Висновки. Підсумок основних ідей доповіді.
08:40-09:00 – Список використаних джерел. Посилання на книги, документацію та матеріали, використані у доповіді.



ДОДАТОК Б
Слайди презентації


Рисунок Б.1 – Титульний лист


Рисунок Б.2 – Зміст доповіді
 

Рисунок Б.3 – Вступ. Проблема несумісності інтерфейсів


Рисунок Б.4 – Загальне визначення патерна


Рисунок Б.5 – Проблематика розробки


Рисунок Б.6 – Використання Adapter як об'єкта-перекладача

 
Рисунок Б.7 – Принцип роботи Adapter: Об’єктний та класовий підходи

 
Рисунок Б.8 – Код без адаптера (Об’єктний Adapter)


Рисунок Б.9  – Код із адаптером (Об’єктний Adapter)

   
Рисунок Б.10 – Код без адаптера (Класовий Adapter)

 
Рисунок Б.11 – Код із адаптером (Класовий Adapter)


Рисунок Б.12 – Переваги використання адаптера. Різниця адаптера від функції


Рисунок Б.13 – Сильні та слабкі сторони використання патерна 


Рисунок Б.14 – Рекомендації щодо застосування патерна

 
Рисунок Б.15 – Підсумок основних ідей та висновки


Рисунок Б.16 – Список використаних джерел



ДОДАТОК В
Приклади програмного коду


Приклад 1: API-запити (Об’єктний адаптер)


1.# Код без адаптера (ручне перетворення)  
2.  
3.import requests    
4.  
5.class OldWeatherAPI:  
6.    """Старий API повертає температуру у градусах Цельсія"""  
7.  
8.    def get_temperature(self, city):  
9.        # Імітуємо запит до API, яке повертає температуру в °C  
10.        print(f"Fetching weather data for {city}...")  
11.        return {"city": city, "temperature": 20}  # 20°C  
12.  
13.class WeatherApp:  
14.    """Додаток, який очікує температуру у Фаренгейтах"""  
15.  
16.    def display_temperature(self, temperature_fahrenheit):  
17.        print(f"Current temperature in {temperature_fahrenheit}°F")  
18.  
19.# Використання без адаптера (ручне перетворення)  
20.  
21.old_api = OldWeatherAPI()  
22.weather_app = WeatherApp()  
23.  
24.data = old_api.get_temperature("Kyiv")  # Отримуємо температуру в °C  
25.temperature_celsius = data["temperature"]  
26.temperature_fahrenheit = (temperature_celsius * 9/5) + 32  # Ручне перетворення  
27.  
28.weather_app.display_temperature(temperature_fahrenheit)  # Ручна конвертація  
29.  
30.# Код з об’єктним адаптером (автоматична конвертація)  
31.  
32.import requests  
33.  
34.class OldWeatherAPI:  
35.    """Старий API повертає температуру у градусах Цельсія"""  
36.  
37.    def get_temperature(self, city):  
38.        print(f"Fetching weather data for {city}...")  
39.        return {"city": city, "temperature": 20}  # 20°C  
40.  
41.class WeatherAdapter:  
42.    """Адаптер, який конвертує температуру в потрібний формат"""  
43.  
44.    def __init__(self, old_api):  
45.        self.old_api = old_api  # Композиція (адаптер містить старий API)  
46.  
47.    def get_temperature_fahrenheit(self, city):  
48.        """Отримує температуру у Фаренгейтах"""  
49.        data = self.old_api.get_temperature(city)  
50.        celsius = data["temperature"] 
51.        fahrenheit = (celsius * 9/5) + 32  
52.        return {"city": city, "temperature": fahrenheit}  
53.  
54.class WeatherApp:  
55.    """Додаток, який очікує температуру у Фаренгейтах"""  
56.  
57.    def display_temperature(self, temperature_fahrenheit):  
58.        print(f"Current temperature in {temperature_fahrenheit}°F")  
59.  
60.# Використання адаптера (автоматична конвертація)  
61.  
62.old_api = OldWeatherAPI()  
63.adapter = WeatherAdapter(old_api)  # Обгортаємо старий API адаптером  
64.weather_app = WeatherApp()  
65.  
66.data = adapter.get_temperature_fahrenheit("Kyiv")  # Отримуємо вже готові °F  
67.weather_app.display_temperature(data["temperature"])  # Все працює автоматично  




Приклад 2: Конвертація XML → JSON (Класовий адаптер)


1.# Код без адаптера (ручне перетворення)  
2.  
3.import xml.etree.ElementTree as ET  
4.import json  
5.  
6.class XMLService:  
7.    """Старий сервіс, який повертає дані у форматі XML"""  
8.  
9.    def get_data(self):  
10.        return """<data>  
11.                    <temperature>25</temperature>  
12.                    <humidity>60</humidity>  
13.                  </data>"""  
14.  
15.class JSONApp:  
16.    """Новий застосунок, який працює тільки з JSON"""  
17.  
18.    def display_data(self, data_json):  
19.        print(f"Received JSON data: {data_json}")  
20.  
21.# Використання без адаптера (ручне перетворення)  
22.  
23.xml_service = XMLService()  
24.json_app = JSONApp()  
25.  
26.xml_data = xml_service.get_data()  # Отримуємо XML  
27.root = ET.fromstring(xml_data)  # Розбираємо XML вручну  
28.data = {child.tag: int(child.text) for child in root}  # Конвертуємо в словник  
29.json_data = json.dumps(data)  # Перетворюємо у JSON  
30.  
31.json_app.display_data(json_data)  # Ручна конвертація кожного разу  
32.  
33.# Код з класовим адаптером (автоматична конвертація)  
34.  
35.import xml.etree.ElementTree as ET  
36.import json  
37.  
38.class XMLService:  
39.    """Старий сервіс, який повертає дані у форматі XML"""  
40.  
41.    def get_data(self):  
42.        return """<data>  
43.                    <temperature>25</temperature>  
44.                    <humidity>60</humidity>  
45.                  </data>"""  
46.  
47.class XMLServiceAdapter(XMLService):  
48.    """Класовий адаптер, який успадковує XMLService та конвертує XML → JSON"""  
49.  
50.    def get_data(self):  
51.        xml_data = super().get_data()  # Викликаємо метод батьківського класу  
52.        root = ET.fromstring(xml_data)  
53.        data = {child.tag: int(child.text) for child in root}  
54.        return json.dumps(data)  # Повертаємо JSON  
55.  
56.class JSONApp:  
57.    """Новий застосунок, який працює тільки з JSON"""  
58.  
59.    def display_data(self, data_json):  
60.        print(f"Received JSON data: {data_json}")  
61.  
62.# Використання адаптера (автоматична конвертація)  
63.  
64.xml_service = XMLServiceAdapter()  # Обгортаємо старий сервіс у адаптер  
65.json_app = JSONApp()  
66.  
67.json_data = xml_service.get_data()  # Отримуємо вже готовий JSON  
68.json_app.display_data(json_data)  # Все працює автоматично  




Приклад звичайної функції (перетворення XML у JSON):

1.import json  
2.import xml.etree.ElementTree as ET  
3.  
4.def xml_to_json(xml_string):  
5.    root = ET.fromstring(xml_string)  
6.    data = {child.tag: child.text for child in root}  
7.    return json.dumps(data, indent=4)  
8.  
9.xml_data = "<data><name>John</name><age>30</age></data>"  
10.json_data = xml_to_json(xml_data)  
11.print(json_data)  
12.  
13.# Приклад адаптера (Об'єктний адаптер, який дозволяє API працювати з XML, а не лише з JSON)  
14.  
15.import json  
16.import xml.etree.ElementTree as ET  
17.  
18.# API, який працює лише з JSON  
19.class JsonAPI:  
20.    def send_request(self, json_data):  
21.        print(f"Sending JSON data to API: {json_data}")  
22.  
23.# Адаптер, який дозволяє працювати з XML, перетворюючи його у JSON  
24.class XmlToJsonAdapter:  
25.    def __init__(self, json_api):  
26.        self.json_api = json_api  
27.  
28.    def send_request(self, xml_data):  
29.        root = ET.fromstring(xml_data)  
30.        data = {child.tag: child.text for child in root}  
31.        json_data = json.dumps(data, indent=4)  
32.        self.json_api.send_request(json_data)  
33.  
34.# Використання адаптера  
35.xml_data = "<data><name>John</name><age>30</age></data>"  
36.json_api = JsonAPI()  
37.adapter = XmlToJsonAdapter(json_api)  
38.adapter.send_request(xml_data)
